Backup this file first
make sure you have gradle and intellij installed


------------------------------------------------------------------------------------------------------------------------------------------
run the following command:
$ git checkout e1ded62
$ gradle cleanIdea idea
$ open wheel-showcase.ipr

In IDEA
    open Main.java
    run it
    see it "works without dependency injection"

------------------------------------------------------------------------------------------------------------------------------------------

Now let's try one simple injection example, all injectors(objects injected to other objects) and injectees(objects injected by other objects) should be annotated with @Component (check out java files under domain package)

run the following command:
$ git checkout 5d7d0e8

In IDEA
    open Main.java
    run it
    see it "works with one simple constructor injection"

------------------------------------------------------------------------------------------------------------------------------------------

Let's try setter injection. There are two ways to use setter inject: add @Inject to field and add @Inject to setter. In either way, setter should be present.

run the following command:
$ git checkout c3790d0

In IDEA
    open Main.java
    run it
    see it "car, truck, and jeep are all running"

Of course, Car can also have other dependencies.
Just using @Component and @Inject, you can accomplish the easy job as above.

------------------------------------------------------------------------------------------------------------------------------------------

Let's try to make the application more OO by introducing a interface "Vehicle", and let Car, Truck, and Jeep all implement it. Replace all Car, Truck, Jeep with Vehicle in AppRunner.java, and see how it behavior.

run the following command:
$ git checkout fee3900

In IDEA
    open Main.java
    run it
    see it fail with "Found more than one candidates for type domain.Vehicle. Cannot determine which one to use!"

That's because Container don't know which concrete class you want. Problem can be solved with Named @Component and @Qualified.

run the following command:
$ git checkout c3fce66

In IDEA
    open Main.java
    run it
    see it behavior correctly now.

Check out what happened to Car, Jeep, Truck, and AppRunner.

------------------------------------------------------------------------------------------------------------------------------------------

How about primitive type as constructor parameters? It's not quite likely to find a proper bean from IOC container with a primitive type...
See the MultiWheelVehicle freak below:

run the following command:
$ git checkout ba7578d

In IDEA
    open Main.java
    run it
    see it tells you what you should do.

Using xml configuration can solve the problem. But wait, don't use primitive as constructor parameter, and you can avoid the trouble. If you really want to do so, go ahead.

run the following command:
$ git checkout 9e6359c

In IDEA
    open Main.java
    run it
    see "multiWheelVehicle is running with 5 wheels".

see what to do in "ioc-config.xml" config to make it work.

------------------------------------------------------------------------------------------------------------------------------------------

xml config also support constructor injection and setter injection. See below:

run the following command:
$ git checkout 62dbb5c

In IDEA
 see "ioc-config.xml" config bean with cons and setter injection.

But when you run the application, it fail with "Found more than one candidates for type domain.AppRunner. Cannot determine which one to use!"
That's because now we have two beans generated by container. One is with @Component, one is configured in xml. So getting bean from container by id instead of by type can solve the problem.

run the following command:
$ git checkout c09383a

In IDEA
    open Main.java
    run it
    see it works well again.

If you pay attention to the configuration of "anotherAppRunner" in ioc-config.xml, you will find that which bean to use for cons/setter injection has no business with the annotations in source file. We can assign any compatible beans to any constructor parameter and setter no matter what the @Qualified annotation says.

------------------------------------------------------------------------------------------------------------------------------------------

You can mix xml config and package scan together to define beans and inject beans

------------------------------------------------------------------------------------------------------------------------------------------

In terms of bean scope, you can configure it in either xml or annotation:

run the following command:
$ git checkout 680519c

In IDEA
    check out AppRunner.java for @Prototype annotation and ioc-config.xml for "prototype" scope. Using these, every time you get bean from container with the same type(only one instance of this type exist) or same id, you get a new instance, otherwise you always get the same instance.

------------------------------------------------------------------------------------------------------------------------------------------

In terms of container scope, refer "ContainerScopeTest.java" in IOC container test source code...

------------------------------------------------------------------------------------------------------------------------------------------

In summary:
    To simply use annotation driven configuration without ambiguous dependency candidates. Use the following code:

        Create container:
            IocContainer container = new IocContainerBuilder().withPackageName(packageName).build();
        Annotations for configuration(compatible with JSR 330)
            @Component: specify classes to be included in container.
            @Inject: Can be put on constructor, field, and setter.

    To use annotation driven configuration with ambiguous dependency candidates. Change a little bit on annotations:

        @Component(<name>): specify a name for bean instantiated from this class.
        @Qualified(id=<name>): specify a bean for certain dependency. Can be applied on fields, constructor parameters, setters.

    Using primitive in DI is not recommended. We only provide primitive dependency injected from constructor. To use primitive injection, xml configuration is needed.

        Create container:
                IocContainer container = new IocContainerBuilder().withConfigFile(configFile).build();
        key words in xml(as you've been familiar with in Spring...):
                bean id class scope constructor-arg property value ref

    Parent scope is supported, and hybrid(annotation and xml) configuration is supported, so you can say:

        IocContainer container = new IocContainerBuilder().withPackageName(packageName)
                                                          .withConfigFile(configFile)
                                                          .withParent(parent)
                                                          .build();